// Here is the annotated C code for version comparisons of the part after the colon.
// (the part before the colon is easy, cause it's just an integer)

// ([0-9]+:)?([^0-9]*[0-9]*)*([.-]([^0-9]*[0-9]*)*)*

int verrevcmp(const char *val, const char *ref)
{
     int vc, rc;
     long vl, rl;
     const char *vp, *rp;
     const char *vsep, *rsep;
    
     // Ensure we start with valid strings that we can traverse.
     if (!val) val= "";
     if (!ref) ref= "";

     // Loop through the various section of the version string, which are delimited by '.' or '-'.
     for (;;) {

          // Find the next digit in the section, and record it's location.
	  vp= val;  while (*vp && !isdigit(*vp)) vp++;
	  rp= ref;  while (*rp && !isdigit(*rp)) rp++;

	  // Loop through the non-digit prefixes.
	  for (;;) {

	       // Check the ascii value of each positionally-related character.
	       vc= (val == vp) ? 0 : *val++;
	       rc= (ref == rp) ? 0 : *ref++;

	       // Break if the end of both prefixes has been reached.
	       if (!rc && !vc) break;

	       // Adjust the lexical comparison so all letters sort earlier than non-letters.
	       if (vc && !isalpha(vc)) vc += 256; /* assumes ASCII character set */
	       if (rc && !isalpha(rc)) rc += 256;

	       // As soon as there is a mismatch, report the comparison.
	       if (vc != rc) return vc - rc;
	  }

	  // Continue the comparison at the next digit of the section.
	  val= vp;
	  ref= rp;

	  // Compare the numeric values of the digit sequences.
	  vl=0;  if (isdigit(*vp)) vl= strtol(val,(char**)&val,10);
	  rl=0;  if (isdigit(*rp)) rl= strtol(ref,(char**)&ref,10);

	  // As soon as there is a mismatch, report the comparison.
	  if (vl != rl) return vl - rl;

	  // If one string has reached the end of the section first, report the comparison.
	  vc = *val;
	  rc = *ref;
	  vsep = strchr(".-", vc);
	  rsep = strchr(".-", rc);
	  if (vsep && !rsep) return -1;
	  if (!vsep && rsep) return +1;

	  // If either string is exhausted, report the comparison.
	  if (!*val && !*ref) return 0;
	  if (!*val) return -1;
	  if (!*ref) return +1;
     }
}

-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------

packagesModel.prototype.versionNewer = function(one, two)
{
	// if one >= two returns false
	// if one < two returns true

	// Split each string on the colon - should only be a maximum of one.
	var e1 = one.split(':');
	var e2 = two.split(':');

	// A missing epoch is equivalent to 0, return if they are different.
	if (e1.length > 1 || e2.length > 1) {
		var prefix1 = e1.length > 1 ? parseInt(e1[0], 10) : 0;
		var prefix2 = e2.length > 1 ? parseInt(e2[0], 10) : 0;
		var diff = prefix2 - prefix1;
		if (diff) return (diff > 0) ? true : false;
	}

	// Split the versions into sections on a period or hyphen.
	var v1 = e1[e1.length > 1 ? 1 : 0].split(/[.-]/);
	var v2 = e2[e2.length > 1 ? 1 : 0].split(/[.-]/);

	// Loop over the array of sections, using the largest one as the limit.
	var lastv = v1.length > v2.length ? v1.length : v2.length;

	var j;
	for (j = 0; j < lastv; j++) {

	       	// If the first version ends early, then the second is greater.
		if (j > v1.length) return true;

	       	// If the second version ends early, then the first is greater.
		if (j > v2.length) return false;

	       	// If both strings have ended, then neither is greater.
		if ((j == v1.length) && (j == v2.length)) return false;

		// Split the sections into alpha and numeric parts.
		var p1 = v1[j].match(/([^0-9]*)([0-9]*)/g);
		var p2 = v2[j].match(/([^0-9]*)([0-9]*)/g);

		// Loop over the array of parts, using the largest one as the limit.
		var lastp = p1.length > p2.length ? p1.length : p2.length;

		var m;
		for (m = 0; m < lastp; m++) {

			// If the first part ends early, then the second is greater.
			if (m > p1.length) return true;

			// If the second part ends early, then the first is greater.
			if (m > p2.length) return false;

			// If both strings have ended, then neither is greater.
			if ((m == p1.length) && (m == p2.length)) return false;

			// If part1 is alpha, and part2 is numeric, then part1 is greater.
			if (p1[m].match(/[^0-9]/) and p2[m].match(/[0-9]/))  return false;

			// If part1 is numeric, and part2 is alpha, then part2 is greater.
			if (p1[m].match(/[0-9]/) and p2[m].match(/[^0-9]/))  return true;

			// Test non-numeric parts
			if (p1[m].match(/[^0-9]/) && p2[m].match(/[^0-9]/)) {

			   // Need to loop through characters here, adding 256 if non-alpha.
			   // Return on the first difference between the characters in the part.

			}

			// Test numeric parts
			if (p1[m].match(/[0-9]/) && p2[m].match(/[0-9]/)) {

			   // Calculate the values of the two sections.
			   var i1 = parseInt(p1[m], 10);
			   var i2 = parseInt(p2[m], 10);

			   // Return if the calculated values of the sections are different.
			   var diff = i2 - i1;
			   if (diff) return (diff > 0) ? true : false;
			}
		}
	}

	return false;
}

